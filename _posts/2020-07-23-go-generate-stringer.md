---
layout: post
title: 如何使用枚举常量名
tags:
  - golang
excerpt_separator: <!--more-->
---

前端最近在做统一化、标准化的一系列框架层面的优化。有关枚举类型的字典统一由后端提供，包括值、中文名和别名。用这个别名转换为有意义的常量，即可直接使用。
简而言之，相当于后端定义的常量名直接给前端。但是golang编译后常量名就没有了，要怎么办呢？

搜索了一番，了解了下`go generate stringer`，觉得是个不错的方案。每个iota类型的常量都要定义一个`type`，再针对这个`type`生成 `String()`方法。这样在任意地方print的时候，就能得到常量名，而不是值。

举例来说：

一般定义iota常量及其`Stringer`可能是这样的……

```golang

type Direction int

const (
    North Direction = iota
    East
    South
    West
)

func (d Direction) String() string {
    return [...]string{"North", "East", "South", "West"}[d]
}
```

使用`go generate`是这样的……

> 首先要`go get golang.org/x/tools/cmd/stringer` 

```golang

//go:generate stringer -type=Direction
type Direction int

const (
    North Direction = iota
    East
    South
    West
)
```
<!--more-->
在这个文件所在路径下执行 `go generate`，会在相同路径下生成一个 `direction_string.go`的文件，内容是这样的……

```
// Code generated by "stringer -type=Direction"; DO NOT EDIT.

package main

import "strconv"

func _() {
	// An "invalid array index" compiler error signifies that the constant values have changed.
	// Re-run the stringer command to generate them again.
	var x [1]struct{}
	_ = x[North-0]
	_ = x[East-1]
	_ = x[South-2]
	_ = x[West-3]
}

const _Direction_name = "NorthEastSouthWest"

var _Direction_index = [...]uint8{0, 5, 9, 14, 18}

func (i Direction) String() string {
	if i < 0 || i >= Direction(len(_Direction_index)-1) {
		return "Direction(" + strconv.FormatInt(int64(i), 10) + ")"
	}
	return _Direction_name[_Direction_index[i]:_Direction_index[i+1]]
}
```

如此一来，该iota常量默认的`String()`即可一键`go generate`生成。

而中文化则需要单独定义map。

```
var Directions = map[Direction]string{
	North: "北",
	East:  "东",
	South: "南",
	West:  "西",
}
```

项目中会定义的iota常量数量不少，接下来就把多个定义好的map丢进一个转化函数（具体见后），用`reflect`即可统一处理。

可以一次处理多个常量，比如 `go generate -type=Direction,Color`，这样两个常量的stringer都会在一个文件里。要注意的是，不同路径(`packages`)下的常量是不可以放在一起的。当然也可以把常量都定义在同个`packages`下。

可以定制化生成的文件名，`go generate --output=stringer.go -type=Direction` 

总结一下，为了满足文章开头所描述的需求:
- 每个iota常量都需要定义为一个`type`，再多定义一个常量和中文名的map
- 当前package的所有常量合并在一起，只写一行`go generate stringer`
- 如果多个package，可以单独写个`generate.sh`脚本把各路径都放进去。

最后附上转化函数。

```golang
type Item struct {
	Code  int64  `json:"code"`
	Name  string `json:"name"`
	Alias string `json:"alias"`
}

func convert(m interface{}) []Item {
	iter := reflect.ValueOf(m).MapRange()
	data := make([]Item, 0)
	for iter.Next() {
		alias := iter.Key().MethodByName("String").Call([]reflect.Value{})
		data = append(data, Item{
			Code:  iter.Key().Int(),
			Name:  iter.Value().String(),
			Alias: alias[0].String(),
		})
	}

	return data
}
```

### References
- [The Go Blog - Generating code](https://blog.golang.org/generate)
- [Command stringer - Godoc](https://godoc.org/golang.org/x/tools/cmd/stringer)
- [Name of a constant given its value - stackoverflow](https://stackoverflow.com/a/43150489)